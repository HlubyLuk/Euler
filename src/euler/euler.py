'''
Created on Nov 3, 2018

@author: HlubyLuk
'''
from abc import ABC, abstractmethod
import math
from functools import reduce


class Problem(ABC):

    @abstractmethod
    def solve(self):
        '''
        Problem solve method.
        '''
        raise NotImplementedError('subclasses must override solve() method!')

    def lcm(self, r=[]):
        '''
        Least common multiple.
        :r `range` for analyze.
        :return `int` of least common multiple.
        '''
        cache = dict()

        for item in r:
            for k, v in self.prime_factors(item).items():
                tmp = cache.get(k, 0)
                if tmp < v:
                    cache.update({k: tmp + v - tmp})

        return reduce(lambda a, b: a * b,
                      map(lambda x: math.pow(x[0], x[1]), cache.items()))

    def prime_factors(self, x):
        '''
        Prime factors of number.
        :return `dict` where key is number, value is how many times.
        '''
        cache = dict()
        number = x
        factor = 2

        while number > 1:
            while number % factor == 0:
                number /= factor
                tmp = cache.get(factor, 0)
                cache.update({factor: tmp + 1})

            factor += 1

        return cache

    def is_palindromic(self, number):
        '''
        Is number same from start to end and end to start.
        :return `True` is same, otherwise `False`
        '''
        return str(number) == str(number)[::-1]

    def is_prime(self, i=1):
        '''
        Analyze is number prime.
        :i `int` to analyze.
        :return `True` is prime, otherwise `False`.
        '''
        # return len([x for x in range(2, int(math.sqrt(i) + 1)) if i % x ==
        # 0]) == 0

        x = 2

        while x * x <= i:
            if (i % x == 0):
                return False

            x += 1

        return True

    def eratosthenes_sief(self, number):
        '''
        In mathematics, the sieve of Eratosthenes is a simple, ancient
        algorithm for finding all prime numbers up to any given limit.
        It does so by iteratively marking as composite the multiples of
        each prime.
        :number top limit
        :return `dict` of booleans, where `True` is not prime, `False` is
        prime.
        '''
        sieve = [False] * (number + 1)
        sieve[0], sieve[1] = True, True

        for item in range(2, int(math.sqrt(number)) + 1):
            if sieve[item]:
                continue

            step = item * 2
            while step <= number:
                sieve[step] = True
                step += item

        return sieve


class Problem1(Problem):
    '''
    Multiples of 3 and 5
    Problem 1
    If we list all the natural numbers below 10 that are multiples of 3 or 5,
    we get 3, 5, 6 and 9. The sum of these multiples is 23.

    Find the sum of all the multiples of 3 or 5 below 1000.
    '''

    def solve(self):
        return sum([x for x in range(1, 1000, 1) if x % 3 == 0 or x % 5 == 0])


class Problem2(Problem):
    '''
    Even Fibonacci numbers
    Problem 2
    Each new term in the Fibonacci sequence is generated by adding the previous
    two terms. By starting with 1 and 2, the first 10 terms will be:

    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

    By considering the terms in the Fibonacci sequence whose values do not
    exceed four million, find the sum of the even-valued terms.
    '''

    def solve(self):
        fibonacci = [1, 2]

        while True:
            index = len(fibonacci)
            x = fibonacci[index - 2] + fibonacci[index - 1]
            fibonacci.append(x)

            if x >= 4000000:
                break

        return sum(filter(lambda x: x % 2 == 0, fibonacci))


class Problem3(Problem):
    '''
    Largest prime factor
    Problem 3
    The prime factors of 13195 are 5, 7, 13 and 29.

    What is the largest prime factor of the number 600851475143 ?
    '''

    def solve(self):
        return sorted(self.prime_factors(600851475143).keys())[-1]


class Problem4(Problem):
    '''
    Largest palindrome product
    Problem 4
    A palindromic number reads the same both ways. The largest palindrome made
    from the product of two 2-digit numbers is 9009 = 91 × 99.

    Find the largest palindrome made from the product of two 3-digit numbers.
    '''

    def solve(self):
        r = range(999, 99, -1)

        return max([x * y for x in r for y in r if self.is_palindromic(x * y)])


class Problem5(Problem):
    '''
    Smallest multiple
    Problem 5
    2520 is the smallest number that can be divided by each of the numbers
    from 1 to 10 without any remainder.

    What is the smallest positive number that is evenly divisible by all of the
    numbers from 1 to 20?
    '''

    def solve(self):
        return self.lcm([x for x in range(1, 21, 1)])


class Problem6(Problem):
    '''
    Sum square difference
    Problem 6
    The sum of the squares of the first ten natural numbers is,

    1^2 + 2^2 + ... + 10^2 = 385
    The square of the sum of the first ten natural numbers is,

    (1 + 2 + ... + 10)^2 = 552 = 3025
    Hence the difference between the sum of the squares of the first ten
    natural numbers and the square of the sum is 3025 − 385 = 2640.

    Find the difference between the sum of the squares of the first one hundred
    natural numbers and the square of the sum.
    '''

    def solve(self):
        seq = [x for x in range(1, 101, 1)]

        return math.pow(sum(seq), 2) - sum(map(lambda x: math.pow(x, 2), seq))


class Problem7(Problem):
    '''
    10001st prime
    Problem 7
    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
    that the 6th prime is 13.

    What is the 10 001st prime number?
    '''

    def solve(self):
        counter = 0
        number = 2

        while True:
            if self.is_prime(number):
                counter += 1

            if counter == 10001:
                break

            number += 1

        return number


class Problem8(Problem):
    '''
    Largest product in a series
    Problem 8
    The four adjacent digits in the 1000-digit number that have the greatest
    product are 9 × 9 × 8 × 9 = 5832.

    73167176531330624919225119674426574742355349194934
    96983520312774506326239578318016984801869478851843
    85861560789112949495459501737958331952853208805511
    12540698747158523863050715693290963295227443043557
    66896648950445244523161731856403098711121722383113
    62229893423380308135336276614282806444486645238749
    30358907296290491560440772390713810515859307960866
    70172427121883998797908792274921901699720888093776
    65727333001053367881220235421809751254540594752243
    52584907711670556013604839586446706324415722155397
    53697817977846174064955149290862569321978468622482
    83972241375657056057490261407972968652414535100474
    82166370484403199890008895243450658541227588666881
    16427171479924442928230863465674813919123162824586
    17866458359124566529476545682848912883142607690042
    24219022671055626321111109370544217506941658960408
    07198403850962455444362981230987879927244284909188
    84580156166097919133875499200524063689912560717606
    05886116467109405077541002256983155200055935729725
    71636269561882670428252483600823257530420752963450

    Find the thirteen adjacent digits in the 1000-digit number that have the
    greatest product. What is the value of this product?
    '''

    def __init__(self):
        self.number_txt = "".join([
            "73167176531330624919225119674426574742355349194934",
            "96983520312774506326239578318016984801869478851843",
            "85861560789112949495459501737958331952853208805511",
            "12540698747158523863050715693290963295227443043557",
            "66896648950445244523161731856403098711121722383113",
            "62229893423380308135336276614282806444486645238749",
            "30358907296290491560440772390713810515859307960866",
            "70172427121883998797908792274921901699720888093776",
            "65727333001053367881220235421809751254540594752243",
            "52584907711670556013604839586446706324415722155397",
            "53697817977846174064955149290862569321978468622482",
            "83972241375657056057490261407972968652414535100474",
            "82166370484403199890008895243450658541227588666881",
            "16427171479924442928230863465674813919123162824586",
            "17866458359124566529476545682848912883142607690042",
            "24219022671055626321111109370544217506941658960408",
            "07198403850962455444362981230987879927244284909188",
            "84580156166097919133875499200524063689912560717606",
            "05886116467109405077541002256983155200055935729725",
            "71636269561882670428252483600823257530420752963450"])

    def solve(self):
        m = (lambda x: int(x))
        r = (lambda y, z: y * z)

        return max([reduce(r, map(m, self.number_txt[x:x + 13:1]))
                    for x in range(0, len(self.number_txt) - 13 + 1, 1)])


class Problem9(Problem):
    '''
    Special Pythagorean triplet
    Problem 9
    A Pythagorean triplet is a set of three natural numbers, a < b < c, for
    which,

    a^2 + b^2 = c^2
    For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

    There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    Find the product abc.
    '''

    def __init__(self):
        self.x = 1000

    def solve(self):
        c = (lambda a, b: self.x - a - b)

        resuts = [{a, b, c(a, b)}
                  for a in range(1, int(self.x / 2))
                  for b in range(1, int(self.x / 3))
                  if a**2 + b**2 == (c(a, b))**2]

        return list(map(lambda x: reduce(lambda y, z: y * z, x), resuts))[0]


class Problem10(Problem):
    '''
    Summation of primes
    Problem 10
    The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

    Find the sum of all the primes below two million.
    '''

    def solve(self):
        # return sum([x for x in range(2, 2000000) if self.is_prime(x)])

        limit = 2000000
        f = (lambda x: x[1] is False)
        m = (lambda x: x[0])

        sieve = self.eratosthenes_sief(limit)
        indexs = [x for x in range(0, limit + 1)]

        return sum(map(m, filter(f, zip(indexs, sieve))))


if __name__ == '__main__':
    pass
